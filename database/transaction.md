# Transaction

## 트랜잭션(Transaction)이란?
- 데이터베이스의 상태를 변화시키는 하나의 작업 단위
- `원자성(Atomicity)`, `일관성(Consistency)`, `격리성(Isolation)`, `지속성(Durability)`의 `ACID 속성`을 만족해야 함
- 여러 개의 작업(쿼리)으로 구성될 수 있으며, 이 작업들은 `모두 성공`하거나 `모두 실패`해야 함

---

## 트랜잭션의 특징
### 1. 원자성(Atomicity)
- 트랜잭션 내의 모든 작업이 성공적으로 완료되거나, 실패 시 모든 작업이 취소되어야 함
- 예를 들어, 은행 계좌 이체 시 출금과 입금 작업이 모두 성공해야 함
- 하나라도 실패하면 전체 트랜잭션이 롤백되어 이전 상태로 되돌아감
- 예시: 
  - 출금 작업이 성공했지만 입금 작업이 실패하면 출금된 금액은 다시 원래 계좌로 되돌려야 함
  - 이체 작업이 완료되지 않은 상태에서 시스템 장애가 발생하면, 출금된 금액이 사라지지 않도록 해야 함
  - 트랜잭션이 시작되면, 모든 작업이 성공적으로 완료될 때까지 데이터베이스에 반영되지 않음
  - 트랜잭션이 완료되면, 모든 작업이 데이터베이스에 반영되어 일관된 상태를 유지함
  - 트랜잭션이 실패하면, 모든 작업이 취소되어 데이터베이스가 이전 상태로 되돌아감


### 2. 일관성(Consistency)
- 트랜잭션이 완료되면 데이터베이스는 일관된 상태를 유지해야 함
- 트랜잭션이 시작되기 전과 후의 데이터베이스 상태가 일관되어야 함
- 예를 들어, 은행 계좌 이체 시 출금과 입금 작업이 모두 성공해야 계좌 잔액이 일관되게 유지됨
- 예시:
  - 트랜잭션이 시작되기 전과 후의 데이터베이스 상태가 일관되어야 함
  - 예를 들어, 은행 계좌 이체 시 출금과 입금 작업이 모두 성공해야 계좌 잔액이 일관되게 유지됨
  - 트랜잭션이 완료되면, 데이터베이스는 일관된 상태를 유지해야 함
  - 트랜잭션이 실패하면, 데이터베이스는 이전 상태로 되돌아가야 함


### 3. 격리성(Isolation)
- 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 서로 영향을 주지 않아야 함
- 트랜잭션 간의 격리 수준을 설정하여 동시성 문제를 해결할 수 있음
- 예를 들어, 두 개의 트랜잭션이 동시에 실행될 때, 하나의 트랜잭션이 다른 트랜잭션의 작업에 영향을 주지 않아야 함
- 예시:
  - 트랜잭션 A와 B가 동시에 실행될 때, A의 작업이 B의 작업에 영향을 주지 않아야 함
  - 예를 들어, 트랜잭션 A가 계좌 잔액을 조회하고, 트랜잭션 B가 계좌 잔액을 업데이트할 때, A는 B의 작업이 완료되기 전까지 B의 작업 결과를 볼 수 없어야 함
  - 격리 수준을 설정하여 동시성 문제를 해결할 수 있음 (예: READ COMMITTED, REPEATABLE READ 등)


### 4. 지속성(Durability)
- 트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 저장되어야 함
- 시스템 장애가 발생하더라도 트랜잭션의 결과는 손실되지 않아야 함
- 예를 들어, 은행 계좌 이체 작업이 성공적으로 완료되면, 출금과 입금 작업의 결과는 영구적으로 저장되어야 함
- 예시:
  - 트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 저장되어야 함
  - 예를 들어, 은행 계좌 이체 작업이 성공적으로 완료되면, 출금과 입금 작업의 결과는 영구적으로 저장되어야 함
  - 시스템 장애가 발생하더라도 트랜잭션의 결과는 손실되지 않아야 함
  - 데이터베이스는 트랜잭션 로그를 사용하여 트랜잭션의 결과를 영구적으로 저장함


---

## 트랜잭션의 상태
### 1. 시작(Active)
- 트랜잭션이 시작된 상태
- 트랜잭션 내의 작업이 진행 중임
- 트랜잭션이 아직 완료되지 않은 상태
- 예시:
  - 트랜잭션이 시작되면, 데이터베이스는 트랜잭션 로그를 생성하고, 트랜잭션 내의 작업을 기록하기 시작함
  - 트랜잭션이 시작된 후, 여러 개의 작업(쿼리)이 실행될 수 있음
  - 트랜잭션이 완료되기 전까지 데이터베이스에 반영되지 않음


### 2. 완료(Committed)
- 트랜잭션이 성공적으로 완료된 상태
- 트랜잭션 내의 모든 작업이 성공적으로 수행되어 데이터베이스에 반영됨
- 트랜잭션 로그에 기록되어 영구적으로 저장됨
- 예시:
  - 트랜잭션이 완료되면, 데이터베이스는 트랜잭션 로그를 사용하여 모든 작업을 영구적으로 저장함
  - 예를 들어, 은행 계좌 이체 작업이 성공적으로 완료되면, 출금과 입금 작업의 결과가 데이터베이스에 반영됨
  - 트랜잭션이 완료된 후에는 더 이상 해당 트랜잭션의 작업을 롤백할 수 없음

    
### 3. 실패(Rolled Back)
- 트랜잭션이 실패하여 모든 작업이 취소된 상태
- 트랜잭션 내의 작업이 모두 롤백되어 데이터베이스가 이전 상태로 되돌아감
- 트랜잭션 로그에 기록되어 데이터베이스의 일관성을 유지함
- 예시:
  - 트랜잭션이 실패하면, 데이터베이스는 트랜잭션 로그를 사용하여 모든 작업을 취소하고 이전 상태로 되돌림
  - 예를 들어, 은행 계좌 이체 작업 중 출금 작업이 성공했지만 입금 작업이 실패한 경우, 출금된 금액은 다시 원래 계좌로 되돌려야 함
  - 트랜잭션이 실패한 후에는 해당 트랜잭션의 작업을 다시 시도할 수 있음


### 4. 중단(Aborted)
- 트랜잭션이 중단된 상태
- 트랜잭션이 시작되었지만, 완료되지 않고 중단됨
- 트랜잭션 로그에 기록되어 데이터베이스의 일관성을 유지함
- 예시:
  - 트랜잭션이 중단되면, 데이터베이스는 트랜잭션 로그를 사용하여 해당 트랜잭션의 작업을 취소하고 이전 상태로 되돌림
  - 예를 들어, 트랜잭션이 시작되었지만, 시스템 장애나 사용자 요청으로 인해 중단된 경우, 해당 트랜잭션의 작업은 모두 취소됨
  - 중단된 트랜잭션은 다시 시도할 수 없으며, 새로운 트랜잭션을 시작해야 함


---

## 트랜잭션의 격리 수준
- 트랜잭션 간의 격리 수준을 설정하여 동시성 문제를 해결할 수 있음
- 격리 수준은 트랜잭션이 다른 트랜잭션의 작업에 영향을 받는 정도를 결정함
- 주요 격리 수준은 다음과 같음:
- ### 1. READ UNCOMMITTED
  - 다른 트랜잭션의 작업이 완료되지 않은 상태에서도 읽을 수 있음
  - 가장 낮은 격리 수준으로, `더티 리드(Dirty Read)`가 발생할 수 있음
  - 예시: 트랜잭션 A가 데이터를 수정 중일 때, 트랜잭션 B가 해당 데이터를 읽으면 A의 작업이 완료되지 않은 상태의 데이터를 읽게 됨


- ### 2. READ COMMITTED
  - 다른 트랜잭션의 작업이 완료된 후에만 읽을 수 있음
  - `더티 리드`는 방지되지만, `논리적 일관성(Logical Consistency)` 문제는 발생할 수 있음
  - 예시: 트랜잭션 A가 데이터를 수정하고 커밋한 후, 트랜잭션 B가 해당 데이터를 읽으면 A의 작업이 완료된 상태의 데이터를 읽게 됨


- ### 3. REPEATABLE READ
  - 트랜잭션이 시작된 후, 같은 데이터를 여러 번 읽을 때 항상 동일한 결과를 보장함
  - `더티 리드`와 `논리적 일관성` 문제는 방지되지만, `팬텀 리드(Phantom Read)` 문제가 발생할 수 있음
  - 예시: 트랜잭션 A가 데이터를 읽은 후, 트랜잭션 B가 해당 데이터를 추가하거나 수정해도 A는 처음 읽은 데이터와 동일한 결과를 얻음


- ### 4. SERIALIZABLE
  - 가장 높은 격리 수준으로, 트랜잭션이 순차적으로 실행되는 것처럼 동작함
  - `더티 리드`, `논리적 일관성`, `팬텀 리드` 문제를 모두 방지함
  - 성능 저하가 발생할 수 있음
  - 예시: 트랜잭션 A와 B가 동시에 실행될 때, A가 완료된 후에 B가 실행되도록 보장함
  
