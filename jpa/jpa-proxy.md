# JPA Proxy

## 1. JPA 프록시란?
- JPA에서 **프록시(Proxy)**란, 실제 엔티티 객체 대신에 **지연 로딩(Lazy Loading)** 을 위해 생성되는 가짜 객체  
프록시 객체는 실제 엔티티 데이터가 필요할 때까지 데이터베이스 조회를 미루기 위해 사용
- 프록시 객체는 실제 엔티티와 동일한 인터페이스를 구현하며, 실제 엔티티에 접근할 때 데이터베이스에서 데이터를 조회하여 채워짐
- 프록시 객체는 엔티티의 식별자(ID)를 가지고 있으며, 이를 통해 실제 엔티티를 조회할 수 있음
- 프록시 객체는 엔티티의 모든 필드에 접근할 수 있지만, 실제 데이터는 필요할 때까지 조회하지 않음

---

## 2. 프록시가 생성되는 경우

- `@ManyToOne`, `@OneToOne` 관계에서 기본적으로 **지연 로딩(LAZY)** 이 설정된 경우
- `EntityManager.find()` 대신 `EntityManager.getReference()` 호출 시
- 컬렉션(`@OneToMany`, `@ManyToMany`)은 기본적으로 지연 로딩 되므로 프록시 컬렉션이 생성됨

---

## 3. 프록시 초기화
- 최초 지연 로딩 시에는 프록시 객체가 생성되지만, 실제 데이터는 조회되지 않음
- 프록시 객체의 필드에 접근하는 순간, JPA는 데이터베이스에서 실제 엔티티 데이터를 조회하여 프록시 객체를 초기화함
- 프록시는 실 객체를 참조만 하며, 실제 엔티티의 데이터를 가지고 있지 않음
- 프록시 객체가 초기화되면, 실제 엔티티와 동일한 상태로 동작하게 됨
- 프록시 객체가 초기화되지 않은 상태에서 필드에 접근하면 `LazyInitializationException` 예외가 발생함

---

## 4. 프록시 동작 원리

- 실제 엔티티 대신에 **프록시 객체**를 반환
- 프록시 객체는 실제 데이터를 가지고 있지 않고, 실제 엔티티 조회는 **필요 시점(접근 시점)** 에 이루어짐
- 예를 들어, 프록시 객체의 특정 필드를 조회하는 순간 DB에서 실제 데이터를 조회

---

## 5. 프록시 동등성(Equality) 비교
- 프록시 객체와 실제 엔티티 객체는 동일한 ID를 가지므로, `equals()` 메서드를 사용하여 비교 가능
- 프록시 객체는 실제 엔티티와 동일한 인터페이스를 구현하므로, `instanceof` 연산자를 사용하여 프록시 객체인지 확인 가능
- 프록시 객체는 실제 엔티티와 동일한 식별자(ID)를 가지므로, `==` 연산자를 사용하여 비교할 수 있지만, 이는 프록시 객체가 초기화되지 않은 경우에는 올바른 결과를 보장하지 않음
- 프록시 객체가 초기화되지 않은 상태에서 `==` 연산자를 사용하면, 프록시 객체와 실제 엔티티 객체가 다르다고 판단될 수 있음
- 따라서, 프록시 객체와 실제 엔티티 객체를 비교할 때는 `equals()` 메서드를 사용하는 것이 안전함
- JPA 엔티티의 equals(Object o) 메서드 구현은 ID 값만 비교하여 재정의함
    ```java
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Entity)) return false;
        Entity entity = (Entity) o;
        return Objects.equals(id, entity.id);
    }
    ```
- 프록시 필드 값은 모두 null로 초기화되며, 실제 엔티티에 접근할 때 데이터베이스에서 값을 조회하여 채워짐
    ```java
    @Entity
    public class User {
        @Id
        private Long id;
        private String name;

        // equals() 메서드 재정의
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof User)) return false;
            User user = (User) o;
            return Objects.equals(id, user.getId())
            && Objects.equals(name, user.getName())
            && Objects.equals(email, user.getEmail());
        }
    }
    ```
---

## 6. 프록시 객체의 장점과 단점
### 장점
- **성능 향상**: 실제 엔티티를 조회하지 않고, 필요한 시점에만 데이터베이스 조회를 수행하여 성능을 향상시킴
- **메모리 절약**: 초기에는 실제 데이터를 로딩하지 않으므로 메모리 사용량을 줄일 수 있음
- **지연 로딩 지원**: 관계형 데이터베이스에서 지연 로딩을 지원하여, 필요한 데이터만 조회할 수 있음
- **유연성**: 프록시 객체를 사용하여 엔티티의 상태를 동적으로 변경할 수 있음
- **Lazy Loading 지원**: 관계형 데이터베이스에서 지연 로딩을 지원하여, 필요한 데이터만 조회할 수 있음

### 단점
- **LazyInitializationException**: 프록시 객체가 초기화되지 않은 상태에서 영속성 컨텍스트가 종료되면 예외 발생
- **직렬화 문제**: 프록시 객체를 직렬화할 때 문제가 발생할 수 있음
- **프록시 객체의 상태 관리**: 프록시 객체의 상태를 관리하기 어려울 수 있으며, 초기화되지 않은 상태에서 필드에 접근하면 예외가 발생할 수 있음
- **프록시 객체의 복잡성**: 프록시 객체를 사용하면 코드가 복잡해질 수 있으며, 디버깅이 어려울 수 있음

---

## 7. 프록시 사용 시 주의사항

- **프록시 강제 초기화**: `Hibernate.initialize(proxy)` 또는 `proxy.getId()` 같은 필드 접근으로 초기화 가능
- **프록시 vs 실제 객체 비교**: `==` 비교는 프록시와 실제 객체가 다를 수 있으므로, `equals()` 메서드로 비교해야 함
- **LazyInitializationException 주의**: 프록시가 초기화되기 전에 영속성 컨텍스트가 종료되면 예외 발생
- **직렬화 문제**: 프록시 객체 직렬화 시 문제 발생 가능, 필요 시 DTO로 변환 권장

---

## 8. 프록시 객체와 실제 엔티티 정리
| 구분            | 프록시 객체                               | 실제 엔티티                            |
|-----------------|---------------------------------------|-----------------------------------|
| 생성 시점        | 초기 조회 시 실제 엔티티 조회를 지연     | 조회 즉시 모든 필드 조회               |
| 타입            | 엔티티 클래스를 상속받은 하위 클래스     | 엔티티 클래스 그대로                   |
| 데이터 로딩 방식 | 지연 로딩(Lazy Loading)                  | 즉시 로딩(Eager Loading)              |
| 데이터 조회 방식 | 프록시 객체 접근 시점에 데이터베이스 조회 | 객체 생성 시점에 이미 데이터 로딩       |
| 데이터 조회 시점 | 필드 접근 시점에 데이터베이스 조회       | 객체 생성 시점에 이미 데이터 로딩       |
| 특징            | 초기에는 필드 값이 없음, 프록시인지 확인 가능 | 모든 필드 값이 채워져 있음              |
| 비교 연산자      | `==` 연산자로 비교 시 프록시 객체와 실제 엔티티가 다를 수 있음 | `==` 연산자로 비교 시 동일한 객체로 판단됨 |
| equals 메서드   | 프록시 객체와 실제 엔티티가 동일한 ID를 가지므로, `equals()` 메서드로 비교 가능 | `equals()` 메서드로 비교 시 동일한 객체로 판단됨 |
| 직렬화          | 프록시 객체 직렬화 시 주의 필요            | 직렬화 시 문제 없음                     |
